# Инструкция по работе проекта Call Analyzer

## Оглавление
1. [Общее описание системы](#общее-описание-системы)
2. [Архитектура проекта](#архитектура-проекта)
3. [Основные компоненты](#основные-компоненты)
4. [Логика работы](#логика-работы)
5. [Структура файлов и папок](#структура-файлов-и-папок)
6. [Конфигурация системы](#конфигурация-системы)
7. [Функциональные возможности](#функциональные-возможности)
8. [Интеграции](#интеграции)
9. [Запуск и управление](#запуск-и-управление)
10. [Отчётность](#отчётность)
11. [Безопасность](#безопасность)
12. [Расширение и модификация](#расширение-и-модификация)

---

## Общее описание системы

**Call Analyzer** — это комплексная система автоматического анализа телефонных звонков для контакт-центров и call-центров.

### Назначение
- Автоматическая транскрипция аудиозаписей звонков
- AI-анализ качества диалогов и результатов разговоров
- Управление кейсами переводов клиентов между станциями
- Управление кейсами перезвонов клиентам
- Детекция звонков от юридических лиц
- Генерация аналитических отчётов
- Уведомления в Telegram о важных событиях
- **Синхронизация звонков с FTP/SFTP серверов**
- Веб-интерфейс для управления и мониторинга

### Ключевые возможности
- Обработка звонков в реальном времени
- Поддержка множества станций (филиалов)
- Многопользовательский режим с разделением прав
- Гибкая система промптов для AI-анализа
- Чек-листы для оценки качества звонков
- Автоматическое отслеживание дедлайнов
- Интеграция с T-Bank VoiceKit и DeepSeek AI
- **Автоматическая синхронизация с FTP/SFTP серверами**
- **Поддержка локальных и удалённых источников звонков**


---

## Архитектура проекта

### Высокоуровневая архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                    Call Analyzer System                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐         ┌──────────────┐                │
│  │ Веб-интерфейс│◄────────┤  База данных │                │
│  │   (Flask)    │         │ (PostgreSQL) │                │
│  └──────┬───────┘         └──────────────┘                │
│         │                                                   │
│         │ Управление                                       │
│         ▼                                                   │
│  ┌──────────────────────────────────────┐                 │
│  │   Демон обработки (main.py)          │                 │
│  │   - Watchdog мониторинг файлов       │                 │
│  │   - Планировщик задач                │                 │
│  │   - Обработчик звонков               │                 │
│  └──────┬───────────────────────────────┘                 │
│         │                                                   │
│         ├──► Транскрипция (T-Bank VoiceKit)               │
│         ├──► AI-анализ (DeepSeek)                         │
│         ├──► Уведомления (Telegram)                       │
│         ├──► Отчёты (Excel)                               │
│         └──► Кейсы (Переводы/Перезвоны)                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Принципы работы

1. **Event-Driven архитектура**: Система реагирует на появление новых файлов
2. **Модульность**: Чёткое разделение на независимые компоненты
3. **Асинхронность**: Параллельная обработка через ThreadPoolExecutor
4. **Персистентность**: Сохранение состояния кейсов в JSON
5. **Многопользовательность**: Изоляция данных между пользователями


---

## Основные компоненты

### 1. Демон обработки (`call_analyzer/`)

**Файл**: `call_analyzer/main.py`

**Функции**:
- Запуск Watchdog для мониторинга папки с записями
- Планирование периодических задач (отчёты, проверки дедлайнов)
- Контроль "тишины" (алерт если нет обработки > 20 минут)
- Переключение между папками при смене дня

**Ключевые переменные**:
- `last_processed_time` - время последней обработки файла
- `last_alert_time` - время последнего алерта о простое

### 2. Обработчик звонков (`call_analyzer/call_handler.py`)

**Класс**: `CallHandler` (наследует `FileSystemEventHandler`)

**Основной поток обработки**:
```python
1. on_created() - событие создания файла
2. Дедупликация (in-memory + lock-файлы)
3. parse_filename() - извлечение метаданных
4. Проверка закрытия кейсов (перевод/перезвон)
5. transcribe_audio_with_tbank() - транскрипция
6. thebai_analyze() - AI-анализ
7. save_transcript_analysis() - сохранение результатов
8. Специальные проверки:
   - is_legal_entity_call() - юрлица
   - run_exental_alert() - чек-лист
   - Создание кейсов перевода/перезвона
```

**Класс**: `IngressHandler`
- Перемещает файлы из корня в папку дня
- Фильтрует служебные папки (runtime)

### 3. Утилиты (`call_analyzer/utils.py`)

**Основные функции**:
- `parse_filename()` - парсинг имён файлов (поддержка 4 форматов)
- `wait_for_file()` - ожидание готовности файла
- `make_request_with_retries()` - HTTP с повторами
- `send_alert()` - отправка в Telegram
- `is_legal_entity_call()` - детекция юрлиц
- `save_transcript_for_analytics()` - сохранение для аналитики


### 4. Модуль переводов (`call_analyzer/transfer_recall/transfer.py`)

**Назначение**: Управление кейсами перевода клиентов между станциями

**Жизненный цикл кейса**:
```
1. Создание (add_transfer_case):
   - Статус: waiting
   - Deadline: 2 часа
   - Primary анализ сохраняется

2. Напоминания:
   - 30 минут: предупреждение
   - 120 минут: просрочка

3. Закрытие (check_new_call_for_transfer):
   - Новый звонок с того же номера
   - Followup анализ
   - Статус: completed/lost
   - Возможна цикличность (новый кейс)
```

**Файлы**:
- `transfer_cases.json` - хранение состояния
- `transfer_prompt.yaml` - промпты для анализа
- `transcriptions/transfer_analysis/` - результаты анализов

### 5. Модуль перезвонов (`call_analyzer/transfer_recall/recall.py`)

**Назначение**: Управление кейсами перезвонов клиентам

**Жизненный цикл кейса**:
```
1. Создание (add_recall_case):
   - Статус: waiting
   - Deadline: 60 минут
   - Primary анализ сохраняется

2. Напоминания:
   - 30 минут: предупреждение
   - 60 минут: потеря

3. Закрытие (check_new_call_for_recall):
   - Новый звонок с родительской станции
   - Followup анализ
   - Статус: completed/lost
   - Возможна цикличность
```

**Файлы**:
- `recall_cases.json` - хранение состояния
- `recall_prompt.yaml` - промпты для анализа
- `transcriptions/recall_analysis/` - результаты анализов

### 6. Модуль синхронизации FTP (`call_analyzer/ftp_sync.py`, `call_analyzer/ftp_sync_manager.py`)

**Назначение**: Автоматическая синхронизация аудиофайлов с удалённых FTP/SFTP серверов

**Класс**: `FtpSync` (`ftp_sync.py`)

**Поддерживаемые протоколы**:
- **FTP** - стандартный File Transfer Protocol (через `ftplib`)
- **SFTP** - SSH File Transfer Protocol (через `paramiko`)

**Основной функционал**:
```python
1. Подключение к FTP/SFTP серверу
   - Аутентификация (логин/пароль)
   - Проверка доступности
   - Тестирование подключения

2. Синхронизация файлов:
   - Сканирование удалённой папки
   - Фильтрация по форматам (fs_, external-, in-, вход_)
   - Проверка расширений (.mp3, .wav)
   - Скачивание в структуру YYYY/MM/DD
   - Проверка на дубликаты

3. Автоматическая обработка:
   - Передача скачанных файлов в CallHandler
   - Обработка через watchdog конвейер
   - Транскрипция и анализ
```

**Класс**: `FtpSyncManager` (`ftp_sync_manager.py`)

**Функции менеджера**:
```
1. Управление фоновыми потоками:
   - Запуск синхронизации для каждого активного подключения
   - Остановка неактивных подключений
   - Контроль интервалов синхронизации

2. Мониторинг статуса:
   - Отслеживание времени последней синхронизации
   - Логирование ошибок
   - Счётчик скачанных файлов

3. Интеграция с БД:
   - Прямое подключение через SQLAlchemy engine
   - Работа вне Flask application context
   - Обновление статистики подключений
```

**Конфигурация FTP подключения**:
```python
{
    "name": "Асиссто",
    "protocol": "sftp",           # ftp или sftp
    "host": "90.156.252.186",
    "port": 22,                    # 21 для FTP, 22 для SFTP
    "username": "user",
    "password": "********",
    "remote_path": "/calls",       # Папка на FTP сервере
    "local_path": "D:/3",          # Локальный путь для сохранения
    "sync_interval": 60,           # Интервал синхронизации (секунды)
    "is_active": true,             # Включено/выключено
    "user_id": 1                   # Владелец подключения
}
```

**Логика синхронизации**:
```
1. Каждые N секунд (sync_interval):
   - Подключение к серверу
   - Получение списка файлов в remote_path
   - Фильтрация по паттернам имён (fs_, external-, in-, вход_)
   - Фильтрация по расширениям (.mp3, .wav)
   
2. Для каждого файла:
   - Проверка: уже скачан?
   - Если нет → скачивание в local_path/YYYY/MM/DD
   - Создание mock события для watchdog
   - Передача в CallHandler.on_created()
   
3. Обновление статистики:
   - last_sync = текущее время
   - download_count += количество скачанных
   - last_error = NULL (если успешно)
```

**Интеграция с пользовательской конфигурацией**:
- Пользователь выбирает тип источника: "Локальная папка" или "FTP подключение"
- Если выбран FTP: система автоматически скачивает файлы в указанный `local_path`
- Файлы обрабатываются идентично локальным через watchdog

**Файлы**:
- `call_analyzer/ftp_sync.py` - клиент FTP/SFTP
- `call_analyzer/ftp_sync_manager.py` - менеджер фоновых синхронизаций
- `database/models.py` - модель `FtpConnection` (таблица БД)


### 7. Модуль отчётов (`call_analyzer/reports/`)

#### `week_full.py` - Еженедельный отчёт по чек-листу
- Сбор анализов за период
- Маппинг консультантов и станций
- Excel с листами: Данные, Сводный отчёт, Общий процент
- Рейтинг консультантов
- Онлайн-сводка через `compute_realtime_summary()`

#### `rr_3.py` - Отчёт по ретрак (10 вопросов)
- Weekly сбор
- Рейтинг и сводный отчёт
- Отправка в Telegram

#### `rr_bad.py` - Отчёт по плохим звонкам
- Фильтр звонков < 60%
- Отдельный отчёт
- Отправка в Telegram

#### `skolko_52.py` - Ежедневная конверсия
- Анализ итоговых тегов
- Поиск follow-up исходов
- LLM-классификация причин отказов
- Excel с подробным листом и сводной таблицей
- Учёт подстанций через STATION_MAPPING

### 7. Веб-интерфейс (`web_interface/`)

**Файл**: `web_interface/app.py` (Flask приложение)

**Основные разделы**:

1. **Главная** (`/`)
   - Статус сервиса обработки
   - Быстрый доступ к функциям

2. **Конфигурация** (`/config`)
   - API ключи (Speechmatics, T-Bank, DeepSeek, Telegram)
   - Пути к файлам
   - Настройки уведомлений
   - Параметры анализа

3. **Станции** (`/stations`)
   - Управление станциями
   - Привязка Telegram чатов
   - Коды станций и подстанций
   - Сопоставление сотрудников

4. **Промпты** (`/prompts`)
   - Основные промпты по станциям
   - Промпты переводов/перезвонов
   - Генерация описаний через AI
   - Синхронизация со станциями

5. **Словарь** (`/vocabulary`)
   - Дополнительная лексика для транскрипции
   - Ключевые слова для юрлиц

6. **Чек-лист** (`/api/script-prompt`)
   - Критерии оценки качества
   - Автосборка промпта из пунктов

7. **FTP подключения** (`/ftp`)
   - Управление FTP/SFTP подключениями
   - Добавление/редактирование/удаление серверов
   - Тестирование подключения
   - Ручной запуск синхронизации
   - Мониторинг статуса (последняя синхронизация, ошибки, счётчик файлов)
   - Выбор FTP источника в конфигурации пользователя

8. **Отчёты** (`/reports`)
   - Запуск генерации
   - Статус и прогресс
   - Проверка Excel
   - Онлайн-сводка

9. **Логи** (`/logs`)
   - Просмотр системных логов
   - Последние 100 строк


---

## Логика работы

### Полный цикл обработки звонка

```
┌─────────────────────────────────────────────────────────────┐
│ 1. ОБНАРУЖЕНИЕ ФАЙЛА                                        │
│    - Watchdog детектирует новый .mp3/.wav файл             │
│    - Проверка префикса: fs_, external-, in-, вход_         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. ДЕДУПЛИКАЦИЯ                                             │
│    - Проверка in-memory set                                 │
│    - Создание lock-файла (межпроцессная защита)            │
│    - Очистка протухших локов (>10 мин)                     │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. ПАРСИНГ ИМЕНИ ФАЙЛА                                      │
│    - Извлечение: номер телефона, код станции, время        │
│    - Поддержка 4 форматов имён                             │
│    - Учёт подстанций через STATION_MAPPING                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. ПРОВЕРКА ЗАКРЫТИЯ КЕЙСОВ                                 │
│    - check_new_call_for_transfer() - закрывает перевод?    │
│    - check_new_call_for_recall() - закрывает перезвон?     │
│    - Если закрывает - followup анализ и выход              │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. ТРАНСКРИПЦИЯ                                             │
│    - T-Bank VoiceKit API (основной)                        │
│    - Стерео/моно режим (TBANK_STEREO_ENABLED)              │
│    - Дополнительная лексика (additional_vocab.yaml)        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. AI-АНАЛИЗ                                                │
│    - DeepSeek API (deepseek-reasoner)                      │
│    - Промпт по коду станции (prompts.yaml)                 │
│    - Генерация тегов: [ТИПЗВОНКА], [КЛАСС], [РЕЗУЛЬТАТ]   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. СОХРАНЕНИЕ РЕЗУЛЬТАТОВ                                   │
│    - transcriptions/script_8/<filename>_analysis.txt       │
│      (диалог + анализ по чек-листу)                        │
│    - transcriptions/<filename>.txt (диалог + анализ)       │
│    - transcript/<filename>.txt (чистый диалог)             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. СПЕЦИАЛЬНЫЕ ПРОВЕРКИ                                     │
│    ├─► Юрлица: ключевые слова + AI подтверждение          │
│    ├─► Чек-лист: run_exental_alert() для всех звонков     │
│    │   └─► Сохранение в script_8/ для отчетов             │
│    ├─► Перевод: если [РЕЗУЛЬТАТ:ПЕРЕВОД]                  │
│    │   └─► Primary анализ → создание кейса                │
│    └─► Перезвон: если [РЕЗУЛЬТАТ:ПЕРЕЗВОНИТЬ]             │
│        └─► Primary анализ → создание кейса                │
└─────────────────────────────────────────────────────────────┘
```


### Логика кейсов переводов

```
СОЗДАНИЕ КЕЙСА:
├─ Условие: [ТИПЗВОНКА:ЦЕЛЕВОЙ] + [РЕЗУЛЬТАТ:ПЕРЕВОД]
├─ Primary анализ с transfer_prompt.yaml
├─ Извлечение тегов:
│  ├─ [ПЕРЕВОД:СТАНЦИЯ=код]
│  └─ [ПЕРЕВОД:УСЛОВИЯ=ЧАС/другое]
└─ Если УСЛОВИЯ=ЧАС:
   ├─ Создание кейса со статусом "waiting"
   ├─ Deadline: 2 часа
   ├─ Сохранение в transfer_cases.json
   └─ Уведомление в Telegram
   Иначе:
   └─ Кейс со статусом "special" (без отсчёта)

МОНИТОРИНГ:
├─ Каждую минуту: check_transfer_notifications()
│  ├─ 30 минут: напоминание
│  └─ 120 минут: просрочка
└─ При новом звонке: check_new_call_for_transfer()
   ├─ Если другая станция → completed
   ├─ Если та же станция до deadline → completed
   ├─ Followup анализ
   ├─ Проверка цикличности (новый [РЕЗУЛЬТАТ:ПЕРЕВОД])
   └─ Обновление transfer_cases.json
```

### Логика кейсов перезвонов

```
СОЗДАНИЕ КЕЙСА:
├─ Условие: [ТИПЗВОНКА:ЦЕЛЕВОЙ] + [РЕЗУЛЬТАТ:ПЕРЕЗВОНИТЬ]
├─ Primary анализ с recall_prompt.yaml
├─ Извлечение тегов:
│  ├─ [ПЕРЕЗВОНИТЬ:КОГДА=ЧАС/другое]
│  └─ [ПЕРЕЗВОНИТЬ:ЧАС]
└─ Если КОГДА=ЧАС или тег [ПЕРЕЗВОНИТЬ:ЧАС]:
   ├─ Создание кейса со статусом "waiting"
   ├─ Deadline: 60 минут
   ├─ Сохранение в recall_cases.json
   └─ Уведомление в Telegram (reply-to на исходное)
   Иначе:
   └─ Кейс со статусом "special" (без отсчёта)

МОНИТОРИНГ:
├─ Каждую минуту: check_recall_notifications()
│  ├─ 30 минут: предупреждение
│  └─ 60 минут: потеря
└─ При новом звонке: check_new_call_for_recall()
   ├─ Проверка: та же родительская станция?
   ├─ Проверка: в пределах 60 минут?
   ├─ Followup анализ
   ├─ Проверка цикличности (новый [РЕЗУЛЬТАТ:ПЕРЕЗВОНИТЬ])
   └─ Обновление recall_cases.json
```


---

## Структура файлов и папок

### Корневая структура проекта

```
CallRecords/
├── call_analyzer/              # Основной модуль обработки
│   ├── main.py                 # Демон (watchdog + scheduler)
│   ├── call_handler.py         # Обработчик событий файлов
│   ├── config.py               # Конфигурация
│   ├── utils.py                # Утилиты
│   ├── services.py             # Обёртки API
│   ├── exental_alert.py        # Расширенный анализ (чек-лист)
│   ├── tbank_transcription.py  # T-Bank VoiceKit интеграция
│   ├── service_manager.py      # Управление сервисом
│   ├── ftp_sync.py             # FTP/SFTP клиент
│   ├── ftp_sync_manager.py     # Менеджер FTP синхронизаций
│   ├── reports/                # Генераторы отчётов
│   │   ├── week_full.py        # Еженедельный по чек-листу
│   │   ├── rr_3.py             # Ретрак отчёт
│   │   ├── rr_bad.py           # Плохие звонки
│   │   └── skolko_52.py        # Конверсия/причины отказов
│   ├── transfer_recall/        # Модуль кейсов
│   │   ├── transfer.py         # Переводы
│   │   ├── recall.py           # Перезвоны
│   │   ├── transfer_prompt.yaml
│   │   └── recall_prompt.yaml
│   └── gen_pet/                # Дополнительные модули
│
├── web_interface/              # Веб-интерфейс (Flask)
│   ├── app.py                  # Главное приложение
│   ├── templates/              # HTML шаблоны
│   │   ├── index.html
│   │   ├── config.html
│   │   ├── stations.html
│   │   ├── prompts.html
│   │   ├── ftp.html            # FTP подключения
│   │   └── ...
│   ├── static/                 # CSS, JS, изображения
│   └── requirements.txt
│
├── database/                   # Модели БД
│   ├── models.py               # SQLAlchemy модели
│   └── migrations.py
│
├── auth/                       # Аутентификация
│   ├── routes.py               # Роуты авторизации
│   └── decorators.py
│
├── common/                     # Общие модули
│   └── user_settings.py        # Настройки пользователей
│
├── config/                     # Конфигурация приложения
│   └── settings.py
│
├── runtime_configs/            # Профили пользователей
│   ├── user_1.json
│   ├── user_2.json
│   └── ...
│
├── scripts/                    # Служебные скрипты
│   ├── init_db.py
│   └── migrate_*.py
│
├── deploy/                     # Развёртывание
│   ├── nginx/
│   ├── systemd/
│   └── setup_ubuntu.sh
│
├── .env                        # Переменные окружения
├── .env.example                # Пример .env
├── prompts.yaml                # Промпты для AI
├── script_prompt_8.yaml        # Чек-лист оценки
├── additional_vocab.yaml       # Дополнительная лексика
├── transfer_cases.json         # Кейсы переводов
├── recall_cases.json           # Кейсы перезвонов
├── requirements.txt            # Python зависимости
│
├── *.bat                       # Скрипты управления (Windows)
│   ├── start_service.bat
│   ├── stop_service.bat
│   ├── start_web_interface.bat
│   └── ...
│
└── *.md                        # Документация
    ├── README.md
    ├── ARCHITECTURE.md
    ├── API_DOCUMENTATION.md
    └── ...
```


### Структура папки записей (BASE_RECORDS_PATH)

```
BASE_RECORDS_PATH/              # Например: D:/calls или D:/3
├── YYYY/                       # Год
│   └── MM/                     # Месяц
│       └── DD/                 # День
│           ├── *.mp3           # Исходные аудиофайлы
│           ├── *.wav
│           ├── transcriptions/ # Результаты обработки
│           │   ├── *.txt       # Диалог + анализ (основной)
│           │   ├── script_8/   # Анализы по чек-листу (ВАЖНО!)
│           │   │   └── *_analysis.txt  # Используется для отчетов
│           │   ├── DD-DD_script/  # Папка отчета за период
│           │   │   ├── tg_bw_calls.txt  # Список звонков
│           │   │   ├── *_analysis.txt   # Копии анализов
│           │   │   └── Отчет_по_скрипту_DD.MM-DD.MM.xlsx
│           │   ├── retrack/    # Анализы ретрак
│           │   ├── transfer_analysis/
│           │   │   ├── primary_*.txt
│           │   │   └── followup_*.txt
│           │   └── recall_analysis/
│           │       ├── primary_*.txt
│           │       └── followup_*.txt
│           └── transcript/     # Чистые транскрипты
│               └── fs_*.txt    # Только диалог (для аналитики)
│
└── runtime/                    # Служебные данные
    └── locks/                  # Lock-файлы для дедупликации
        └── *.lock
```

**Важные замечания**:
- Файлы анализов по чек-листу ДОЛЖНЫ находиться в `script_8/`
- При генерации отчета система ищет `script_8/` в приоритете
- Папка `DD-DD_script/` создается автоматически при генерации отчета
- Имена файлов анализов: `<original_filename>_analysis.txt`

### Форматы имён файлов

#### 1. Формат `fs_*` (основной)
```
Входящий: fs_[phone]_[station]_[datetime]_...
Пример: fs_79056154237_9301_2025-10-13-10-28-03_...

Исходящий: fs_[station]_[phone]_[datetime]_...
Пример: fs_9301_79056154237_2025-10-13-10-28-03_...
```

#### 2. Формат `external-*` и `in-*`
```
external-[station]-[phone]-[YYYYMMDD]-[HHMMSS]-...
Пример: external-9301-79056154237-20251013-102803-...

in-[station]-[phone]-[YYYYMMDD]-[HHMMSS]-...
Пример: in-9301-79056154237-20251013-102803-...
```

#### 3. Формат `вход_*` (новый)
```
вход_[station_name][station_code]_с_[from_phone]_на_[to_phone]_от_[YYYY]_[MM]_[DD]
Пример: вход_EkbFocusMal128801_с_79536098664_на_73432260822_от_2025_10_20
```


---

## Конфигурация системы

### Файл `.env` (переменные окружения)

```bash
# API ключи
SPEECHMATICS_API_KEY=your_key_here
TBANK_API_KEY=your_key_here
TBANK_SECRET_KEY=your_secret_here
THEBAI_API_KEY=your_key_here
TELEGRAM_BOT_TOKEN=your_token_here

# Пути
BASE_RECORDS_PATH=D:/calls
PROMPTS_FILE=D:/path/to/prompts.yaml
ADDITIONAL_VOCAB_FILE=D:/path/to/additional_vocab.yaml
SCRIPT_PROMPT_8_PATH=D:/path/to/script_prompt_8.yaml

# Telegram
ALERT_CHAT_ID=-1002413323859
LEGAL_ENTITY_CHAT_ID=-1002413323859
TG_CHANNEL_NIZH=-1002413323859
TG_CHANNEL_OTHER=-1002413323859

# База данных
DATABASE_URL=postgresql://user:password@localhost/call_analyzer

# Веб-интерфейс
SECRET_KEY=your_secret_key_here
LOGIN_DISABLED=False
DEFAULT_ADMIN_USERNAME=admin
DEFAULT_ADMIN_PASSWORD=admin123
```

### Файл `call_analyzer/config.py`

**Основные секции**:

1. **API ключи**:
   - `SPEECHMATICS_API_KEY` - Speechmatics (legacy)
   - `TBANK_API_KEY`, `TBANK_SECRET_KEY` - T-Bank VoiceKit
   - `THEBAI_API_KEY`, `THEBAI_URL`, `THEBAI_MODEL` - DeepSeek
   - `TELEGRAM_BOT_TOKEN` - Telegram бот

2. **Пути**:
   - `BASE_RECORDS_PATH` - корень записей
   - `PROMPTS_FILE` - промпты
   - `ADDITIONAL_VOCAB_FILE` - словарь
   - `SCRIPT_PROMPT_8_PATH` - чек-лист

3. **Станции**:
   - `STATION_NAMES` - {код: название}
   - `STATION_CHAT_IDS` - {код: [chat_ids]}
   - `STATION_MAPPING` - {основной_код: [подстанции]}
   - `NIZH_STATION_CODES` - коды Нижегородского региона

4. **Сотрудники**:
   - `EMPLOYEE_BY_EXTENSION` - {код_станции: имя_сотрудника}

5. **Юрлица**:
   - `LEGAL_ENTITY_KEYWORDS` - список ключевых слов

6. **Форматы файлов**:
   - `FILENAME_PATTERNS` - регулярные выражения
   - `FILENAME_FORMATS` - описания форматов
   - `supported_extensions` - ['.mp3', '.wav']


### Файл `prompts.yaml`

```yaml
# Промпт по умолчанию
default: |
  Проанализируй диалог и определи результат разговора.
  Используй теги: [ТИПЗВОНКА:...], [КЛАСС:...], [РЕЗУЛЬТАТ:...]

# Именованные промпты (anchors)
quality_prompt: |
  Оцени качество обслуживания клиента...

conversion_prompt: |
  Определи причину отказа клиента...

# Промпты по станциям
stations:
  "128801": |
    Проанализируй звонок на станцию Фокус на Малышева.
    Определи: тип звонка, класс, результат.
    
  "303": |
    Проанализируй звонок на станцию Крауля 44.
    Определи: тип звонка, класс, результат.
```

### Файл `script_prompt_8.yaml` (чек-лист)

```yaml
checklist:
  - title: "1. Приветствие"
    prompt: "Консультант поздоровался и представился"
    
  - title: "2. Выявление потребности"
    prompt: "Консультант задал уточняющие вопросы"
    
  - title: "3. Презентация"
    prompt: "Консультант рассказал о продукте/услуге"
    
  # ... остальные пункты

# Собранный промпт (генерируется автоматически)
prompt: |
  Оцени звонок по следующим критериям:
  1. Приветствие
  2. Выявление потребности
  3. Презентация
  ...
```

### Файл `additional_vocab.yaml`

```yaml
additional_vocab:
  - content: "Бествей"
    sounds_like: ["бест вей", "бэст вэй"]
  - content: "Крауля"
    sounds_like: ["краулья", "кроуля"]
  - content: "ИБС"
    sounds_like: ["и бэ эс", "ибс"]
```

### Файлы кейсов (JSON)

#### `transfer_cases.json`
```json
[
  {
    "phone_number": "+79056154237",
    "incoming_station": "128801",
    "call_time": "2025-01-15T10:30:00",
    "status": "waiting",
    "transfer_station": "303",
    "transfer_conditions": "ЧАС",
    "analysis": "Клиент хочет перевестись...",
    "created_at": "2025-01-15T10:31:00",
    "deadline": "2025-01-15T12:30:00"
  }
]
```

#### `recall_cases.json`
```json
[
  {
    "phone_number": "+79056154237",
    "station_code": "128801",
    "call_time": "2025-01-15T10:30:00",
    "status": "waiting",
    "recall_when": null,
    "analysis": "Клиент просит перезвонить...",
    "created_at": "2025-01-15T10:31:00",
    "deadline": "2025-01-15T11:30:00"
  }
]
```


---

## Функциональные возможности

### 1. Автоматическая обработка звонков

**Что делает**:
- Мониторинг папки с записями в реальном времени
- Автоматическая транскрипция аудио в текст
- AI-анализ качества и результата разговора
- Сохранение результатов в структурированном виде

**Поддерживаемые форматы**:
- Аудио: MP3, WAV
- Имена файлов: 4 различных формата (см. выше)

**Производительность**:
- Параллельная обработка (ThreadPoolExecutor, 4 потока)
- Дедупликация событий (in-memory + lock-файлы)
- Retry механизм для API запросов

### 2. Управление кейсами переводов

**Функции**:
- Автоматическое создание кейса при результате "ПЕРЕВОД"
- Отслеживание дедлайнов (2 часа)
- Напоминания (30 мин, 120 мин)
- Автоматическое закрытие при новом звонке
- Follow-up анализ результата
- Поддержка цикличности (повторные переводы)

**Уведомления**:
- Создание кейса
- Напоминание через 30 минут
- Просрочка через 120 минут
- Закрытие кейса (успешно/потеряно)

### 3. Управление кейсами перезвонов

**Функции**:
- Автоматическое создание кейса при результате "ПЕРЕЗВОНИТЬ"
- Отслеживание дедлайнов (60 минут)
- Напоминания (30 мин, 60 мин)
- Автоматическое закрытие при новом звонке
- Follow-up анализ результата
- Поддержка цикличности

**Уведомления**:
- Создание кейса (reply-to на исходное сообщение)
- Предупреждение через 30 минут
- Потеря через 60 минут
- Закрытие кейса (успешно/потеряно)

### 4. Детекция юридических лиц

**Алгоритм**:
1. Быстрая проверка по ключевым словам
2. AI-подтверждение через DeepSeek
3. Отправка уведомления в специальный чат

**Ключевые слова**:
- компания, организация, ИП
- индивидуальный предприниматель
- по счету, от юр лица
- по расчетному счету

**Уведомление содержит**:
- Номер телефона
- Код станции
- Время звонка
- Выжимка из анализа
- Фрагмент диалога


### 5. Оценка качества по чек-листу

**Модуль**: `exental_alert.py`

**Функции**:
- Анализ каждого звонка по детальному чек-листу
- Оценка по множеству критериев (обычно 8-10 пунктов)
- Сохранение результатов в отдельную папку
- Использование для еженедельных отчётов

**Критерии оценки** (пример):
1. Приветствие и представление
2. Выявление потребности
3. Презентация продукта/услуги
4. Работа с возражениями
5. Завершение разговора
6. Общее впечатление
7. Грамотность речи
8. Соблюдение скриптов

### 6. Генерация отчётов

#### Еженедельный отчёт (`week_full.py`)
- **Период**: неделя (настраивается, можно указать любой период)
- **Данные**: анализы по чек-листу
- **Формат**: Excel с 3 листами
- **Содержание**:
  - Детальные данные по каждому звонку
  - Сводный отчёт по консультантам
  - Общий процент по станциям
  - Рейтинг консультантов
- **Важно**: Автоматически сбрасывает время на начало/конец дня для корректного попадания звонков в период

#### Отчёт по ретрак (`rr_3.py`)
- **Период**: неделя
- **Критерии**: 10 специальных вопросов
- **Формат**: Excel
- **Отправка**: Telegram

#### Отчёт по плохим звонкам (`rr_bad.py`)
- **Фильтр**: звонки с оценкой < 60%
- **Формат**: Excel
- **Отправка**: Telegram

#### Ежедневная конверсия (`skolko_52.py`)
- **Период**: день
- **Анализ**: причины отказов клиентов
- **LLM-классификация**: автоматическая категоризация
- **Формат**: Excel с подробным листом и сводной таблицей
- **Отправка**: Telegram

### 7. Синхронизация с FTP/SFTP серверами

**Функции**:
- Автоматическая загрузка файлов с удалённых серверов
- Поддержка протоколов: FTP, SFTP (SSH)
- Множественные подключения (разные серверы для разных пользователей)
- Настраиваемый интервал синхронизации (по умолчанию 60 секунд)
- Фильтрация файлов по именам и расширениям
- Автоматическое размещение в структуру YYYY/MM/DD
- Идентичная обработка с локальными файлами

**Управление подключениями**:
- Добавление нового FTP/SFTP сервера
- Редактирование параметров (хост, порт, логин, пароль, пути)
- Тестирование подключения перед сохранением
- Активация/деактивация без удаления
- Ручной запуск синхронизации
- Удаление подключения

**Мониторинг**:
- Статус: активно/неактивно
- Время последней синхронизации
- Счётчик скачанных файлов
- Последняя ошибка (если была)
- Логирование всех операций

**Интеграция с конфигурацией пользователя**:
- Выбор источника звонков: "Локальная папка" или "FTP подключение"
- При выборе FTP: автоматическое скачивание в указанный путь
- Seamless переключение между источниками без потери данных

**Безопасность**:
- Пароли хранятся в зашифрованном виде
- Поддержка SSH ключей для SFTP
- Изоляция подключений между пользователями
- Проверка прав доступа к локальным путям

### 8. Веб-интерфейс управления

**Возможности**:
- Управление конфигурацией без редактирования кода
- Управление станциями и сотрудниками
- Редактирование промптов для AI
- Управление словарём транскрипции
- Редактирование чек-листа оценки
- **Управление FTP/SFTP подключениями**
- Запуск и мониторинг отчётов
- Просмотр логов системы
- Онлайн-сводка по звонкам
- Старт/стоп сервиса обработки

**Многопользовательский режим**:
- Регистрация и авторизация
- Роли: admin, user
- Изоляция данных между пользователями
- Персональные настройки и профили
- **Индивидуальные FTP подключения**


---

## Интеграции

### 1. T-Bank VoiceKit (транскрипция)

**Модуль**: `tbank_transcription.py`

**API**:
- Endpoint: T-Bank VoiceKit API
- Метод: POST с аудиофайлом
- Аутентификация: API Key + Secret Key

**Режимы работы**:
- **Стерео** (TBANK_STEREO_ENABLED=True): 2 спикера (клиент/консультант)
- **Моно** (TBANK_STEREO_ENABLED=False): автоматическая диаризация

**Формат ответа**:
```
Спикер 1: Здравствуйте, компания Бествей
Спикер 2: Добрый день, хочу узнать о бассейнах
Спикер 1: Конечно, расскажу подробнее...
```

**Обработка ошибок**:
- Retry механизм (3 попытки)
- Логирование ошибок
- Fallback на Speechmatics (опционально)

### 2. DeepSeek AI (анализ)

**API**:
- Endpoint: https://api.deepseek.com/v1/chat/completions
- Модель: deepseek-reasoner
- Аутентификация: Bearer token

**Промпты**:
- Загружаются из `prompts.yaml`
- Специфичны для каждой станции
- Поддержка именованных промптов (anchors)

**Формат запроса**:
```json
{
  "model": "deepseek-reasoner",
  "messages": [
    {
      "role": "user",
      "content": "ПРОМПТ\n\nВот диалог:\nТРАНСКРИПТ"
    }
  ]
}
```

**Ожидаемые теги в ответе**:
- `[ТИПЗВОНКА:ЦЕЛЕВОЙ/НЕЦЕЛЕВОЙ]`
- `[КЛАСС:A/B/C/D]`
- `[РЕЗУЛЬТАТ:ПРОДАЖА/ПЕРЕВОД/ПЕРЕЗВОНИТЬ/НЕТ]`

**Обработка ошибок**:
- Retry механизм (3 попытки)
- Timeout: 90 секунд
- Логирование ошибок

### 3. Telegram Bot API (уведомления)

**Функции**:
- Отправка алертов
- Отправка отчётов (Excel файлы)
- Reply-to для связанных сообщений
- Форматирование (Markdown)

**Типы уведомлений**:
1. **Системные алерты**:
   - Ошибки обработки
   - Простой системы > 20 минут
   - Критические события

2. **Кейсы переводов**:
   - Создание кейса
   - Напоминания (30 мин, 120 мин)
   - Закрытие кейса

3. **Кейсы перезвонов**:
   - Создание кейса
   - Напоминания (30 мин, 60 мин)
   - Закрытие кейса

4. **Юридические лица**:
   - Детекция звонка от юрлица
   - Выжимка анализа

5. **Отчёты**:
   - Еженедельные отчёты
   - Ежедневная конверсия
   - Специальные отчёты

**Каналы**:
- `ALERT_CHAT_ID` - системные алерты
- `LEGAL_ENTITY_CHAT_ID` - юрлица
- `TG_CHANNEL_NIZH` - Нижегородский регион
- `TG_CHANNEL_OTHER` - остальные регионы
- `STATION_CHAT_IDS` - чаты по станциям


---

## Запуск и управление

### Установка и настройка

#### 1. Требования
```
- Python 3.8+
- PostgreSQL 12+
- Windows (для bat-скриптов) или Linux
- 4+ GB RAM
- Достаточно места для записей звонков
```

#### 2. Установка зависимостей
```bash
# Создание виртуального окружения
python -m venv venv

# Активация (Windows)
venv\Scripts\activate

# Активация (Linux)
source venv/bin/activate

# Установка зависимостей
pip install -r requirements.txt
pip install -r web_interface/requirements.txt
```

#### 3. Настройка базы данных
```bash
# Создание базы данных
createdb call_analyzer

# Инициализация схемы
python scripts/init_db.py
```

#### 4. Настройка конфигурации
```bash
# Копирование примера .env
copy .env.example .env

# Редактирование .env (указать API ключи, пути)
notepad .env
```

### Запуск системы

#### Windows (через bat-скрипты)

**Запуск всей системы**:
```cmd
start_all.bat
```

**Запуск сервиса обработки**:
```cmd
start_service.bat
```

**Запуск веб-интерфейса**:
```cmd
start_web_interface.bat
```

**Остановка**:
```cmd
stop_service.bat
stop_web_interface.bat
```

**Проверка статуса**:
```cmd
status_service.bat
status_web_interface.bat
```

**Перезапуск**:
```cmd
restart_service.bat
restart_web_interface.bat
```

#### Linux (через systemd)

**Установка сервисов**:
```bash
cd deploy
sudo ./setup_ubuntu.sh
```

**Управление**:
```bash
# Запуск
sudo systemctl start call-analyzer
sudo systemctl start call-analyzer-web

# Остановка
sudo systemctl stop call-analyzer
sudo systemctl stop call-analyzer-web

# Статус
sudo systemctl status call-analyzer
sudo systemctl status call-analyzer-web

# Автозапуск
sudo systemctl enable call-analyzer
sudo systemctl enable call-analyzer-web
```

### Доступ к веб-интерфейсу

**URL**: http://localhost:5000

**Учётная запись по умолчанию**:
- Логин: admin
- Пароль: admin123

**Важно**: Сменить пароль после первого входа!


### Мониторинг и логи

#### Файлы логов

**Демон обработки**:
```
bestway.log                    # Глобальный лог
bestway_user-1.log            # Лог пользователя 1
bestway_user-2.log            # Лог пользователя 2
```

**Веб-интерфейс**:
```
web_interface/web_interface.log
```

**Просмотр логов**:
```bash
# Последние 100 строк
tail -n 100 bestway.log

# Мониторинг в реальном времени
tail -f bestway.log

# Поиск ошибок
grep ERROR bestway.log
```

#### Просмотр через веб-интерфейс

1. Открыть http://localhost:5000/logs
2. Выбрать период
3. Фильтровать по уровню (INFO, WARNING, ERROR)

#### Метрики системы

**Через веб-интерфейс**:
- Статус сервиса (запущен/остановлен)
- PID процесса
- Время последнего запуска
- Онлайн-сводка по звонкам

**API endpoint**:
```
GET /api/status
GET /api/summary/realtime?start_date=2025-01-15&end_date=2025-01-16
```

### Обслуживание

#### Очистка старых данных

**Lock-файлы** (автоматически):
- Протухшие локи (>10 мин) удаляются автоматически

**Логи** (вручную):
```bash
# Архивация старых логов
tar -czf logs_archive_2025-01.tar.gz bestway*.log
rm bestway*.log
```

**Записи звонков** (вручную):
```bash
# Архивация старых записей (например, старше 3 месяцев)
# Зависит от политики хранения данных
```

#### Резервное копирование

**База данных**:
```bash
# Создание бэкапа
pg_dump call_analyzer > backup_$(date +%Y%m%d).sql

# Восстановление
psql call_analyzer < backup_20250115.sql
```

**Конфигурация**:
```bash
# Бэкап конфигов
tar -czf config_backup_$(date +%Y%m%d).tar.gz \
  .env \
  prompts.yaml \
  script_prompt_8.yaml \
  additional_vocab.yaml \
  transfer_cases.json \
  recall_cases.json \
  runtime_configs/
```


---

## Отчётность

### Типы отчётов

#### 1. Еженедельный отчёт по чек-листу

**Модуль**: `reports/week_full.py`

**Запуск**:
- Автоматически: воскресенье в 20:10
- Вручную: через веб-интерфейс `/reports`
- Программно: `run_week_full()`

**Параметры**:
- Период: последние 7 дней (настраивается)
- Станции: все или выбранные
- Консультанты: все или выбранные

**Структура Excel**:

**Лист "Данные"**:
| Дата | Время | Станция | Консультант | Критерий 1 | ... | Критерий 8 | Итого % |
|------|-------|---------|-------------|------------|-----|------------|---------|

**Лист "Сводный отчёт"**:
| Консультант | Станция | Кол-во звонков | Средний % | Критерий 1 | ... |
|-------------|---------|----------------|-----------|------------|-----|

**Лист "Общий процент по станциям"**:
| Станция | Средний % | Рейтинг |
|---------|-----------|---------|

**Отправка**: Telegram (все настроенные чаты)

#### 2. Отчёт по ретрак

**Модуль**: `reports/rr_3.py`

**Запуск**:
- Автоматически: воскресенье в 20:02
- Вручную: через веб-интерфейс

**Критерии** (10 вопросов):
1. Приветствие
2. Выявление потребности
3. Презентация
4. Работа с возражениями
5. Завершение
6. Грамотность
7. Скрипты
8. Эмпатия
9. Активное слушание
10. Результат

**Формат**: Excel с рейтингом консультантов

#### 3. Отчёт по плохим звонкам

**Модуль**: `reports/rr_bad.py`

**Запуск**:
- Автоматически: воскресенье в 20:05
- Вручную: через веб-интерфейс

**Фильтр**: звонки с оценкой < 60%

**Содержание**:
- Дата и время звонка
- Консультант
- Станция
- Оценка по критериям
- Итоговый процент
- Комментарии

#### 4. Ежедневная конверсия

**Модуль**: `reports/skolko_52.py`

**Запуск**:
- Автоматически: ежедневно в 20:00
- Вручную: через веб-интерфейс

**Анализ**:
- Целевые звонки
- Продажи
- Отказы с причинами
- LLM-классификация причин

**Структура Excel**:

**Лист "Отчёт"**:
| Дата | Станция | Консультант | Результат | Причина отказа | Категория |
|------|---------|-------------|-----------|----------------|-----------|

**Лист "Сводная таблица"**:
| Станция | Целевых | Продаж | Конверсия % | Причины отказов |
|---------|---------|--------|-------------|-----------------|


### Онлайн-сводка

**API**: `/api/summary/realtime`

**Параметры**:
- `start_date` (опционально): YYYY-MM-DD
- `end_date` (опционально): YYYY-MM-DD

**Пример запроса**:
```
GET /api/summary/realtime?start_date=2025-01-15&end_date=2025-01-16
```

**Формат ответа**:
```json
{
  "success": true,
  "period": {
    "start": "2025-01-15T00:00:00",
    "end": "2025-01-16T23:59:59"
  },
  "summary": {
    "total_calls": 150,
    "stations_count": 5,
    "stations": [
      {
        "code": "128801",
        "name": "Фокус на Малышева",
        "consultants": [
          {
            "name": "Иванов И.И.",
            "calls_count": 30,
            "average_score": 85.5,
            "criteria": {
              "1": 90,
              "2": 85,
              ...
            }
          }
        ]
      }
    ]
  }
}
```

**Использование**:
- Мониторинг в реальном времени
- Дашборды
- Интеграция с внешними системами

### Настройка расписания отчётов

**Файл**: `call_analyzer/main.py`

**Редактирование**:
```python
# Пример: запуск run_skolko() в 20:00
if time_str == "20:00":
    run_skolko_52()

# Запуск run_week_full() по воскресеньям в 20:10
if day_of_week == 6 and time_str == "20:10":
    run_week_full()

# По воскресеньям в 20:02 -> run_rr_3
if day_of_week == 6 and time_str == "20:02":
    run_rr_3()

# По воскресеньям в 20:05 -> run_rr_bad
if day_of_week == 6 and time_str == "20:05":
   run_rr_bad()
```

**Примечание**: `day_of_week` - 0=понедельник, 6=воскресенье


---

## Безопасность

### Защита API ключей

**Рекомендации**:
1. Хранить ключи в `.env` файле
2. Добавить `.env` в `.gitignore`
3. Использовать переменные окружения на продакшене
4. Регулярно ротировать ключи
5. Ограничить права доступа к файлам конфигурации

**Пример `.gitignore`**:
```
.env
*.log
transfer_cases.json
recall_cases.json
runtime_configs/
__pycache__/
*.pyc
venv/
```

### Защита веб-интерфейса

**Аутентификация**:
- Flask-Login для управления сессиями
- Хеширование паролей (werkzeug.security)
- Защита от CSRF (рекомендуется добавить Flask-WTF)

**Роли пользователей**:
- `admin` - полный доступ ко всем функциям
- `user` - ограниченный доступ (только свои данные)

**Рекомендации**:
1. Сменить дефолтный пароль администратора
2. Использовать сложные пароли
3. Настроить HTTPS (через nginx/apache)
4. Ограничить доступ по IP (firewall)
5. Регулярно обновлять зависимости

**Пример nginx конфигурации**:
```nginx
server {
    listen 443 ssl;
    server_name call-analyzer.example.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### Защита данных

**Персональные данные**:
- Номера телефонов
- Записи разговоров
- Транскрипты

**Меры защиты**:
1. Ограничение доступа к папке с записями
2. Шифрование базы данных (опционально)
3. Регулярное резервное копирование
4. Политика хранения данных (удаление старых записей)
5. Логирование доступа к данным

**Права доступа к файлам** (Linux):
```bash
# Папка с записями
chmod 750 /path/to/calls
chown call-analyzer:call-analyzer /path/to/calls

# Конфигурация
chmod 600 .env
chown call-analyzer:call-analyzer .env

# Логи
chmod 640 *.log
chown call-analyzer:call-analyzer *.log
```

### Мониторинг безопасности

**Логирование**:
- Все попытки входа (успешные и неуспешные)
- Изменения конфигурации
- Доступ к API
- Ошибки аутентификации

**Алерты**:
- Множественные неудачные попытки входа
- Изменения критичных настроек
- Необычная активность


---

## Расширение и модификация

### Добавление новой станции

#### 1. Через веб-интерфейс (рекомендуется)

1. Открыть http://localhost:5000/stations
2. Нажать "Добавить станцию"
3. Заполнить:
   - Код станции (например, "401")
   - Название (например, "Новая станция")
   - Telegram Chat ID (например, "-1002413323859")
   - Подстанции (опционально, через запятую)
4. Сохранить
5. Система автоматически:
   - Обновит `config.py`
   - Синхронизирует промпты
   - Перезагрузит конфигурацию

#### 2. Вручную (для продвинутых)

**Файл**: `call_analyzer/config.py`

```python
STATION_NAMES = {
    "128801": "Фокус на Малышева",
    "303": "Крауля 44",
    "401": "Новая станция",  # Добавить
}

STATION_CHAT_IDS = {
    '128801': ['-1002413323859'],
    '303': ['-1002413323859'],
    '401': ['-1002413323859'],  # Добавить
}

# Если есть подстанции
STATION_MAPPING = {
    '128801': ['128802', '128804'],
    '303': ['311', '301'],
    '401': ['402', '403'],  # Добавить
}
```

**Файл**: `prompts.yaml`

```yaml
stations:
  "401": |
    Проанализируй звонок на станцию Новая станция.
    Определи: тип звонка, класс, результат.
```

### Добавление нового критерия в чек-лист

#### 1. Через веб-интерфейс

1. Открыть http://localhost:5000/prompts
2. Перейти на вкладку "Чек-лист"
3. Нажать "Добавить критерий"
4. Заполнить:
   - Заголовок (например, "9. Использование CRM")
   - Описание (например, "Консультант зафиксировал данные в CRM")
5. Сохранить
6. Система автоматически обновит `script_prompt_8.yaml`

#### 2. Вручную

**Файл**: `script_prompt_8.yaml`

```yaml
checklist:
  - title: "1. Приветствие"
    prompt: "Консультант поздоровался и представился"
  # ... существующие критерии
  - title: "9. Использование CRM"  # Добавить
    prompt: "Консультант зафиксировал данные в CRM"

# Обновить собранный промпт
prompt: |
  Оцени звонок по следующим критериям:
  1. Приветствие
  ...
  9. Использование CRM
```


### Создание нового типа отчёта

#### Шаблон модуля отчёта

**Файл**: `call_analyzer/reports/my_report.py`

```python
import logging
from datetime import datetime, timedelta
from pathlib import Path
import pandas as pd
from openpyxl import Workbook

try:
    from call_analyzer import config
    from call_analyzer.utils import send_alert
except ImportError:
    import config
    from utils import send_alert

logger = logging.getLogger(__name__)

def run_my_report(start_date=None, end_date=None):
    """
    Генерация пользовательского отчёта
    
    Args:
        start_date: начальная дата (datetime)
        end_date: конечная дата (datetime)
    """
    try:
        logger.info("[MyReport] Начало генерации отчёта")
        
        # 1. Определение периода
        if not end_date:
            end_date = datetime.now()
        if not start_date:
            start_date = end_date - timedelta(days=7)
        
        # 2. Сбор данных
        data = collect_data(start_date, end_date)
        
        # 3. Анализ данных
        analyzed_data = analyze_data(data)
        
        # 4. Генерация Excel
        excel_path = generate_excel(analyzed_data, start_date, end_date)
        
        # 5. Отправка в Telegram
        send_report_to_telegram(excel_path)
        
        logger.info("[MyReport] Отчёт успешно сгенерирован")
        return True
        
    except Exception as e:
        logger.error(f"[MyReport] Ошибка генерации отчёта: {e}")
        send_alert(f"Ошибка генерации отчёта: {e}")
        return False

def collect_data(start_date, end_date):
    """Сбор данных за период"""
    data = []
    
    # Перебор дней в периоде
    current_date = start_date
    while current_date <= end_date:
        day_folder = Path(config.BASE_RECORDS_PATH) / \
                     current_date.strftime("%Y/%m/%d") / \
                     "transcriptions"
        
        if day_folder.exists():
            # Чтение файлов анализов
            for file_path in day_folder.glob("*.txt"):
                analysis = parse_analysis_file(file_path)
                if analysis:
                    data.append(analysis)
        
        current_date += timedelta(days=1)
    
    return data

def analyze_data(data):
    """Анализ собранных данных"""
    # Ваша логика анализа
    return data

def generate_excel(data, start_date, end_date):
    """Генерация Excel файла"""
    wb = Workbook()
    ws = wb.active
    ws.title = "Отчёт"
    
    # Заголовки
    ws.append(["Дата", "Станция", "Консультант", "Метрика 1", "Метрика 2"])
    
    # Данные
    for item in data:
        ws.append([
            item.get('date'),
            item.get('station'),
            item.get('consultant'),
            item.get('metric1'),
            item.get('metric2')
        ])
    
    # Сохранение
    filename = f"my_report_{start_date:%Y%m%d}_{end_date:%Y%m%d}.xlsx"
    excel_path = Path("reports") / filename
    excel_path.parent.mkdir(exist_ok=True)
    wb.save(excel_path)
    
    return excel_path

def send_report_to_telegram(excel_path):
    """Отправка отчёта в Telegram"""
    import requests
    
    url = f"https://api.telegram.org/bot{config.TELEGRAM_BOT_TOKEN}/sendDocument"
    
    with open(excel_path, 'rb') as f:
        files = {'document': f}
        data = {
            'chat_id': config.ALERT_CHAT_ID,
            'caption': f"📊 Отчёт за период"
        }
        response = requests.post(url, files=files, data=data)
    
    if response.status_code == 200:
        logger.info("[MyReport] Отчёт отправлен в Telegram")
    else:
        logger.error(f"[MyReport] Ошибка отправки: {response.text}")

def parse_analysis_file(file_path):
    """Парсинг файла анализа"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Извлечение данных из файла
        # Ваша логика парсинга
        
        return {
            'date': datetime.now(),
            'station': 'unknown',
            'consultant': 'unknown',
            'metric1': 0,
            'metric2': 0
        }
    except Exception as e:
        logger.error(f"Ошибка парсинга {file_path}: {e}")
        return None

if __name__ == "__main__":
    run_my_report()
```

#### Добавление в планировщик

**Файл**: `call_analyzer/main.py`

```python
# Импорт нового отчёта
from call_analyzer.reports.my_report import run_my_report

# Добавление в основной цикл
while True:
    now = datetime.now()
    time_str = now.strftime("%H:%M")
    day_of_week = now.weekday()
    
    # Запуск нового отчёта каждый день в 21:00
    if time_str == "21:00":
        run_my_report()
    
    # ... остальной код
```


### Добавление нового формата имени файла

#### 1. Определение регулярного выражения

**Файл**: `call_analyzer/config.py`

```python
FILENAME_PATTERNS = {
    # Существующие форматы
    'fs_pattern': r'^fs_([^_]+)_([^_]+)_([^_]+)_',
    'external_pattern': r'^(?:external|in)-([^\-]+)-([^\-]+)-(\d{8})-(\d{6})(?:-.+)?',
    'direction_pattern': r'^вход_([a-zA-Z\-]+)(\d+)_с_(\d+)_на_(\d+)_от_(\d{4})_(\d{1,2})_(\d{1,2})(?:\.\w+)?',
    
    # Новый формат
    'my_pattern': r'^myprefix_(\d+)_(\d+)_(\d{14})\.mp3$',
    # Группы: (1) номер телефона, (2) код станции, (3) дата-время YYYYMMDDHHMMSS
    
    'supported_extensions': ['.mp3', '.wav'],
}

FILENAME_FORMATS = {
    # ... существующие форматы
    
    'my_format': {
        'pattern': 'myprefix_[phone]_[station]_[YYYYMMDDHHmmss].mp3',
        'description': 'Мой пользовательский формат',
        'example': 'myprefix_79056154237_9301_20251013102803.mp3'
    }
}
```

#### 2. Обновление функции парсинга

**Файл**: `call_analyzer/utils.py`

```python
def parse_filename(filename: str):
    """
    Парсинг имени файла для извлечения метаданных
    
    Returns:
        tuple: (phone_number, station_code, call_datetime)
    """
    import re
    from datetime import datetime
    
    # ... существующая логика для других форматов
    
    # Новый формат: myprefix_[phone]_[station]_[YYYYMMDDHHmmss].mp3
    my_match = re.match(config.FILENAME_PATTERNS['my_pattern'], filename)
    if my_match:
        phone = my_match.group(1)
        station = my_match.group(2)
        datetime_str = my_match.group(3)  # YYYYMMDDHHmmss
        
        # Парсинг даты-времени
        call_dt = datetime.strptime(datetime_str, '%Y%m%d%H%M%S')
        
        # Нормализация номера
        if not phone.startswith('+'):
            phone = '+' + phone
        
        return phone, station, call_dt
    
    # Если ни один формат не подошёл
    logger.warning(f"Не удалось распарсить имя файла: {filename}")
    return None, None, None
```

#### 3. Тестирование

```python
# Тест парсинга
from call_analyzer.utils import parse_filename

test_filename = "myprefix_79056154237_9301_20251013102803.mp3"
phone, station, call_dt = parse_filename(test_filename)

print(f"Телефон: {phone}")        # +79056154237
print(f"Станция: {station}")      # 9301
print(f"Дата-время: {call_dt}")   # 2025-10-13 10:28:03
```


### Интеграция с внешними системами

#### Webhook для уведомлений

**Пример**: Отправка уведомлений в Slack

**Файл**: `call_analyzer/integrations/slack.py`

```python
import requests
import logging

logger = logging.getLogger(__name__)

SLACK_WEBHOOK_URL = "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

def send_slack_notification(message, channel="#call-analyzer"):
    """
    Отправка уведомления в Slack
    
    Args:
        message: текст сообщения
        channel: канал Slack
    """
    try:
        payload = {
            "channel": channel,
            "username": "Call Analyzer Bot",
            "text": message,
            "icon_emoji": ":telephone_receiver:"
        }
        
        response = requests.post(SLACK_WEBHOOK_URL, json=payload)
        
        if response.status_code == 200:
            logger.info("Уведомление отправлено в Slack")
        else:
            logger.error(f"Ошибка отправки в Slack: {response.text}")
            
    except Exception as e:
        logger.error(f"Ошибка отправки в Slack: {e}")

# Использование в call_handler.py
from integrations.slack import send_slack_notification

# После обработки звонка
send_slack_notification(
    f"Обработан звонок от {phone_number} на станции {station_code}"
)
```

#### REST API для внешнего доступа

**Файл**: `web_interface/api/external.py`

```python
from flask import Blueprint, request, jsonify
from functools import wraps

api_bp = Blueprint('api', __name__, url_prefix='/api/v1')

# Простая аутентификация по API ключу
def require_api_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        if api_key != 'YOUR_SECRET_API_KEY':
            return jsonify({'error': 'Invalid API key'}), 401
        return f(*args, **kwargs)
    return decorated_function

@api_bp.route('/calls', methods=['GET'])
@require_api_key
def get_calls():
    """
    Получение списка звонков
    
    Query params:
        - start_date: YYYY-MM-DD
        - end_date: YYYY-MM-DD
        - station: код станции
    """
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    station = request.args.get('station')
    
    # Логика получения данных
    calls = []  # Ваша логика
    
    return jsonify({
        'success': True,
        'calls': calls
    })

@api_bp.route('/reports/<report_type>', methods=['POST'])
@require_api_key
def generate_report(report_type):
    """
    Запуск генерации отчёта
    
    Body:
        {
            "start_date": "2025-01-15",
            "end_date": "2025-01-16"
        }
    """
    data = request.get_json()
    
    # Запуск генерации отчёта
    # Ваша логика
    
    return jsonify({
        'success': True,
        'message': f'Отчёт {report_type} запущен'
    })

# Регистрация в app.py
from api.external import api_bp
app.register_blueprint(api_bp)
```

**Использование**:
```bash
# Получение звонков
curl -H "X-API-Key: YOUR_SECRET_API_KEY" \
     "http://localhost:5000/api/v1/calls?start_date=2025-01-15&end_date=2025-01-16"

# Запуск отчёта
curl -X POST \
     -H "X-API-Key: YOUR_SECRET_API_KEY" \
     -H "Content-Type: application/json" \
     -d '{"start_date":"2025-01-15","end_date":"2025-01-16"}' \
     "http://localhost:5000/api/v1/reports/weekly"
```


---

## Troubleshooting (Решение проблем)

### Проблема: Сервис не запускается

**Симптомы**:
- `start_service.bat` не работает
- Процесс сразу завершается
- Нет записей в логах

**Решения**:

1. **Проверить Python**:
```cmd
python --version
# Должно быть 3.8+
```

2. **Проверить зависимости**:
```cmd
pip install -r requirements.txt
```

3. **Проверить конфигурацию**:
```cmd
python -c "import call_analyzer.config as config; print(config.BASE_RECORDS_PATH)"
```

4. **Проверить права доступа**:
```cmd
# Убедиться, что папка BASE_RECORDS_PATH существует и доступна
```

5. **Запустить вручную для диагностики**:
```cmd
cd call_analyzer
python main.py
# Смотреть вывод ошибок
```

### Проблема: Транскрипция не работает

**Симптомы**:
- Файлы обрабатываются, но транскрипт пустой
- Ошибки в логах про T-Bank API

**Решения**:

1. **Проверить API ключи**:
```python
# В .env или config.py
TBANK_API_KEY=...
TBANK_SECRET_KEY=...
```

2. **Проверить доступность API**:
```bash
curl -X POST https://api.tbank.ru/voicekit/... \
     -H "Authorization: Bearer YOUR_KEY"
```

3. **Проверить формат файла**:
- Поддерживаются: MP3, WAV
- Размер: не более 100 MB
- Длительность: не более 2 часов

4. **Включить подробное логирование**:
```python
# В call_analyzer/tbank_transcription.py
logging.basicConfig(level=logging.DEBUG)
```

### Проблема: AI-анализ возвращает пустой результат

**Симптомы**:
- Транскрипт есть, но анализ пустой
- Ошибки про DeepSeek API

**Решения**:

1. **Проверить API ключ**:
```python
THEBAI_API_KEY=...
THEBAI_URL=https://api.deepseek.com/v1/chat/completions
THEBAI_MODEL=deepseek-reasoner
```

2. **Проверить промпт**:
```yaml
# В prompts.yaml
stations:
  "128801": |
    Проанализируй звонок...
```

3. **Проверить лимиты API**:
- Квота запросов
- Размер промпта + транскрипта

4. **Тестовый запрос**:
```python
from call_analyzer.call_handler import thebai_analyze

result = thebai_analyze("Тестовый диалог", "Проанализируй")
print(result)
```


### Проблема: Кейсы не закрываются автоматически

**Симптомы**:
- Новый звонок не закрывает кейс перевода/перезвона
- Кейсы остаются в статусе "waiting"

**Решения**:

1. **Проверить парсинг номера**:
```python
from call_analyzer.utils import parse_filename

phone, station, dt = parse_filename("fs_79056154237_9301_2025-01-15-10-30-00.mp3")
print(f"Номер: {phone}")  # Должен быть +79056154237
```

2. **Проверить логику закрытия**:
```python
# В call_analyzer/transfer_recall/transfer.py
# Убедиться, что функция check_new_call_for_transfer() вызывается
```

3. **Проверить формат номера в кейсе**:
```json
// В transfer_cases.json
{
  "phone_number": "+79056154237",  // Должен быть с +
  ...
}
```

4. **Проверить коды станций**:
```python
# Основной код станции должен совпадать
# Учитывается STATION_MAPPING для подстанций
```

### Проблема: Отчёты не генерируются

**Симптомы**:
- Отчёты не приходят в Telegram
- Нет файлов Excel
- Сообщение "Не было найдено данных для записи в Excel"

**Решения**:

1. **Проверить расписание**:
```python
# В call_analyzer/main.py
# Убедиться, что время и день недели правильные
if day_of_week == 6 and time_str == "20:10":
    run_week_full()
```

2. **Запустить вручную**:
```python
from call_analyzer.reports.week_full import run_week_full
from datetime import datetime

# Указать конкретный период
today = datetime.now()
run_week_full(start_date=today, end_date=today, base_folder="D:\\3")
```

3. **Проверить наличие данных**:
```bash
# Убедиться, что есть файлы анализов в script_8
ls BASE_RECORDS_PATH/YYYY/MM/DD/transcriptions/script_8/

# Проверить что файлы имеют формат *_analysis.txt
```

4. **Проверить Telegram**:
```python
# Проверить TELEGRAM_BOT_TOKEN и chat_id
from call_analyzer.utils import send_alert
send_alert("Тест")
```

5. **Типичные проблемы после исправлений**:
   - **Проблема**: Файлы анализа не копируются в папку отчета
   - **Причина**: Система ищет папку `script_8` в приоритете, а не другие папки со словом "script"
   - **Решение**: Убедитесь что анализы сохраняются в `transcriptions/script_8/`, а не в `transcriptions/13-13_script/`
   
   - **Проблема**: Звонки не попадают в период
   - **Причина**: Время звонка не входит в диапазон из-за неправильного сброса времени
   - **Решение**: Функция `run_week_full()` теперь автоматически сбрасывает время на 00:00:00 - 23:59:59
   
   - **Проблема**: Ошибка "station_names is not defined"
   - **Причина**: Отсутствие инициализации переменных конфигурации
   - **Решение**: Добавлены строки получения конфигурации в начале функций `create_excel_report()` и `create_summary_report()`
   
   - **Проблема**: Ошибка "NoneType object has no attribute 'get'"
   - **Причина**: Функция `get_station_groups()` не возвращала значение
   - **Решение**: Добавлен `return station_groups` в конце функции

### Проблема: Веб-интерфейс не открывается

**Симптомы**:
- http://localhost:5000 не отвечает
- Ошибка "Connection refused"

**Решения**:

1. **Проверить запуск**:
```cmd
status_web_interface.bat
```

2. **Проверить порт**:
```cmd
netstat -ano | findstr :5000
```

3. **Проверить логи**:
```cmd
type web_interface\web_interface.log
```

4. **Запустить вручную**:
```cmd
cd web_interface
python app.py
```

5. **Проверить зависимости**:
```cmd
pip install -r web_interface/requirements.txt
```


### Проблема: Высокая нагрузка на систему

**Симптомы**:
- Медленная обработка звонков
- Высокое использование CPU/RAM
- Задержки в уведомлениях

**Решения**:

1. **Увеличить количество потоков**:
```python
# В call_analyzer/call_handler.py
executor = ThreadPoolExecutor(max_workers=8)  # Было 4
```

2. **Оптимизировать промпты**:
- Сократить размер промптов
- Убрать лишние инструкции

3. **Настроить кэширование**:
```python
# Кэшировать результаты анализа
# Не обрабатывать повторно одинаковые файлы
```

4. **Разделить нагрузку**:
- Запустить несколько экземпляров для разных станций
- Использовать профили пользователей

5. **Мониторинг ресурсов**:
```bash
# Windows
tasklist | findstr python

# Linux
top -p $(pgrep -f main.py)
```

---

## FAQ (Часто задаваемые вопросы)

### Q: Можно ли обрабатывать звонки в реальном времени?

**A**: Да, система работает в режиме реального времени. Watchdog отслеживает появление новых файлов и сразу запускает обработку. Среднее время обработки одного звонка: 30-60 секунд (зависит от длительности и скорости API).

### Q: Поддерживается ли работа с несколькими call-центрами?

**A**: Да, через систему станций и подстанций. Каждая станция может иметь:
- Свой код
- Своё название
- Свои Telegram чаты
- Свой промпт для анализа
- Подстанции (дочерние коды)

### Q: Можно ли изменить критерии оценки звонков?

**A**: Да, через веб-интерфейс или редактирование `script_prompt_8.yaml`. Можно:
- Добавлять новые критерии
- Удалять существующие
- Изменять описания
- Менять веса критериев

### Q: Как долго хранятся записи звонков?

**A**: Система не удаляет файлы автоматически. Политику хранения нужно настроить вручную:
- Архивация старых записей
- Удаление через N месяцев
- Резервное копирование

### Q: Можно ли интегрировать с CRM?

**A**: Да, через:
- REST API (создать эндпоинты)
- Webhook (отправка событий)
- Прямую интеграцию (модификация кода)

### Q: Поддерживается ли работа на Linux?

**A**: Да, система кроссплатформенная. Для Linux:
- Использовать systemd вместо bat-скриптов
- Настроить через `deploy/setup_ubuntu.sh`
- Все остальное работает идентично

### Q: Можно ли использовать другие AI модели?

**A**: Да, нужно:
1. Изменить `THEBAI_URL` и `THEBAI_MODEL` в конфигурации
2. Адаптировать формат запроса в `thebai_analyze()`
3. Убедиться, что модель возвращает нужные теги

### Q: Как добавить новый язык транскрипции?

**A**: Для T-Bank VoiceKit:
1. Проверить поддержку языка в API
2. Изменить параметр `language` в запросе
3. Адаптировать промпты для нового языка

### Q: Как настроить синхронизацию с FTP сервером?

**A**: Через веб-интерфейс:
1. Открыть http://localhost:5000/ftp
2. Нажать "Добавить FTP подключение"
3. Заполнить параметры:
   - Название (произвольное)
   - Протокол (FTP или SFTP)
   - Хост (IP или домен)
   - Порт (21 для FTP, 22 для SFTP)
   - Логин и пароль
   - Удалённая папка на сервере
   - Локальный путь для сохранения
   - Интервал синхронизации (секунды)
4. Нажать "Тест подключения" для проверки
5. Если успешно - "Сохранить"
6. Активировать подключение
7. В конфигурации пользователя выбрать "FTP подключение" как источник звонков

### Q: Поддерживается ли одновременная работа с FTP и локальными файлами?

**A**: Да, но для каждого пользователя настраивается один источник:
- Пользователь A может использовать FTP сервер 1
- Пользователь B может использовать локальную папку
- Пользователь C может использовать FTP сервер 2

Переключение между источниками происходит через страницу "Конфигурация".

---

## Инструкция по работе с FTP

### Настройка FTP подключения

#### 1. Добавление нового подключения

1. **Открыть страницу FTP**:
   ```
   http://localhost:5000/ftp
   ```

2. **Нажать кнопку "Добавить FTP подключение"**

3. **Заполнить форму**:
   
   **Основные параметры**:
   - **Название**: Произвольное имя (например, "Сервер Асиссто")
   - **Протокол**: 
     - `ftp` - стандартный FTP
     - `sftp` - безопасный SFTP через SSH
   
   **Подключение**:
   - **Хост**: IP адрес или домен (например, `90.156.252.186`)
   - **Порт**: 
     - `21` для FTP
     - `22` для SFTP
   - **Имя пользователя**: логин на FTP сервере
   - **Пароль**: пароль (хранится в зашифрованном виде)
   
   **Пути**:
   - **Удалённая папка**: Путь к папке на FTP сервере (например, `/calls` или `/home/user/recordings`)
   - **Локальный путь**: Куда сохранять файлы локально (например, `D:/3` или `/var/calls/user_1`)
   
   **Настройки синхронизации**:
   - **Интервал (сек)**: Как часто проверять новые файлы (по умолчанию `60` секунд)
   - **Активно**: Включить/выключить автоматическую синхронизацию

4. **Тестирование подключения**:
   - Нажмите кнопку "Тест подключения"
   - Дождитесь результата:
     - ✅ Успешно: "Подключение успешно! Найдено X файлов"
     - ❌ Ошибка: Описание проблемы

5. **Сохранение**:
   - Если тест успешен → нажать "Сохранить"
   - Подключение появится в списке

#### 2. Редактирование подключения

1. Найти подключение в списке
2. Нажать кнопку "✏️" (Редактировать)
3. Изменить нужные параметры
4. **Важно**: При редактировании можно оставить поле пароля пустым - существующий пароль сохранится
5. Нажать "Сохранить"

#### 3. Удаление подключения

1. Найти подключение в списке
2. Нажать кнопку "🗑️" (Удалить)
3. Подтвердить удаление

#### 4. Ручная синхронизация

1. Найти подключение в списке
2. Нажать кнопку "🔄" (Синхронизировать сейчас)
3. Система сразу проверит сервер и скачает новые файлы

#### 5. Активация/деактивация

- **Активное подключение** (зелёный бейдж):
  - Автоматическая синхронизация запущена
  - Проверка новых файлов каждые N секунд
  
- **Неактивное подключение** (серый бейдж):
  - Автоматическая синхронизация остановлена
  - Можно запустить вручную кнопкой "🔄"

Для изменения статуса:
1. Редактировать подключение
2. Установить/снять галочку "Активно"
3. Сохранить

### Выбор FTP как источника звонков

После создания FTP подключения нужно настроить его использование:

1. **Открыть страницу "Конфигурация"**:
   ```
   http://localhost:5000/config
   ```

2. **Найти раздел "Пути"**

3. **Выбрать тип источника**:
   - Переключить с "Локальная папка" на "FTP подключение"

4. **Выбрать подключение**:
   - В выпадающем списке выбрать нужное FTP подключение

5. **Указать локальный путь для скачанных файлов** (опционально):
   - По умолчанию используется путь из настроек FTP подключения

6. **Сохранить конфигурацию**

После этого:
- Система автоматически начнёт скачивать файлы с FTP
- Файлы размещаются в структуру `local_path/YYYY/MM/DD`
- Обработка происходит автоматически (транскрипция + анализ)

### Мониторинг работы FTP

На странице `/ftp` для каждого подключения отображается:

- **Статус**: Активно/Неактивно
- **Последняя синхронизация**: Время последней проверки сервера
- **Скачано файлов**: Общий счётчик за всё время
- **Последняя ошибка**: Если была проблема - описание

**Логи синхронизации**:
- Все операции FTP логируются в системный лог
- Просмотр: http://localhost:5000/logs
- Фильтр по ключевым словам: "FTP", "ftp_sync"

**Типичные сообщения в логах**:
```
[INFO] FTP Асиссто: файлы будут сохраняться в D:\3\2025\11\14
[INFO] Connected (version 2.0, client OpenSSH_8.9p1)
[INFO] Authentication (password) successful!
[INFO] Найдено 5 файлов на FTP сервере 90.156.252.186
[INFO] ✓ Скачан файл: external-303-+79056154237.wav
[INFO] → Файл передан в обработку
[INFO] FTP синхронизация Асиссто завершена. Скачано файлов: 1
```

### Требования к файлам на FTP

Система обрабатывает только файлы, соответствующие критериям:

**Имя файла должно начинаться с**:
- `fs_` - основной формат
- `external-` - внешние звонки
- `in-` - входящие
- `вход_` - входящие (кириллица)

**Расширение файла**:
- `.mp3`
- `.wav`

**Примеры валидных имён**:
```
✅ fs_79056154237_303_2025-11-14-10-30-00.mp3
✅ external-303-79056154237-20251114-103000.wav
✅ in-128801-79056154237-20251114-103000.mp3
✅ вход_EkbFocusMal128801_с_79536098664_на_73432260822.wav
```

**Примеры невалидных имён**:
```
❌ call_recording.mp3 (неправильный префикс)
❌ fs_79056154237_303.txt (неправильное расширение)
❌ recording-303-phone.mp3 (неправильный формат)
```

### Troubleshooting FTP

#### Проблема: Тест подключения не проходит

**Возможные причины**:
1. **Неправильные учётные данные**
   - Проверить логин/пароль
   - Убедиться что аккаунт активен

2. **Неправильный хост или порт**
   - Проверить IP адрес
   - FTP: порт 21
   - SFTP: порт 22

3. **Файрвол блокирует соединение**
   - Проверить правила файрвола
   - Разрешить исходящие соединения на нужный порт

4. **Удалённая папка не существует**
   - Проверить путь `/calls` на FTP сервере
   - Убедиться что у пользователя есть доступ

#### Проблема: Файлы не скачиваются

**Проверить**:
1. **Подключение активно?**
   - На странице /ftp статус должен быть "Активно"

2. **Файлы соответствуют формату?**
   - Имя должно начинаться с `fs_`, `external-`, `in-`, `вход_`
   - Расширение `.mp3` или `.wav`

3. **Файлы уже скачаны?**
   - Система пропускает существующие файлы
   - Проверить `local_path/YYYY/MM/DD`

4. **Права доступа к локальной папке?**
   - Убедиться что система может записывать в `local_path`

#### Проблема: Файлы скачиваются, но не обрабатываются

**Проверить**:
1. **Сервис обработки запущен?**
   - На главной странице статус "Сервис запущен"
   - Если нет → нажать "Запустить"

2. **Файлы попадают в правильную папку?**
   - Должна быть структура `local_path/YYYY/MM/DD`
   - Проверить логи: "→ Файл передан в обработку"

3. **Watchdog мониторит эту папку?**
   - Проверить конфигурацию пользователя
   - `base_records_path` должен соответствовать `local_path` из FTP

4. **Проблемы с путями на Ubuntu/Linux?**
   - Система автоматически нормализует пути для кроссплатформенности
   - На Ubuntu пути разрешаются через `Path.resolve()` для получения абсолютных путей
   - Проверить логи на наличие предупреждений о путях
   - Убедиться, что пути указаны в правильном формате для Linux (например, `/var/calls` вместо `D:/calls`)

#### Проблема: Большая задержка синхронизации

**Решение**:
1. Уменьшить интервал синхронизации:
   - Редактировать подключение
   - Установить меньшее значение (например, 30 секунд)
   - Минимум: 10 секунд

2. Оптимизировать:
   - Не хранить на FTP тысячи файлов в одной папке
   - Периодически очищать старые файлы
   - Использовать SFTP вместо FTP (быстрее)

#### Проблема: Файлы не обрабатываются на Ubuntu после скачивания с FTP

**Симптомы**:
- Файлы успешно скачиваются с FTP сервера
- Файлы находятся в правильной папке `local_path/YYYY/MM/DD`
- Но обработка не запускается (нет транскрипции и анализа)

**Причина**:
- Проблема с нормализацией путей на Ubuntu/Linux
- Относительные пути не разрешаются корректно

**Решение**:
1. **Проверить логи**:
   ```bash
   tail -f /var/log/call-analyzer/app.log | grep -i "ftp\|путь\|path"
   ```
   - Ищите сообщения: "→ Файл передан в обработку"
   - Ищите предупреждения о путях

2. **Проверить формат путей**:
   - На Ubuntu используйте абсолютные пути (например, `/var/calls` вместо `D:/calls`)
   - Убедитесь, что путь указан в настройках FTP подключения правильно

3. **Проверить права доступа**:
   ```bash
   ls -la /var/calls/YYYY/MM/DD/
   # Убедитесь, что файлы доступны для чтения
   ```

4. **Перезапустить сервис обработки**:
   ```bash
   sudo systemctl restart call-analyzer-service
   # или
   sudo systemctl restart call-analyzer
   ```

**Примечание**: Система автоматически нормализует пути для кроссплатформенности. На Ubuntu пути разрешаются через `Path.resolve()` для получения абсолютных путей, что обеспечивает корректную обработку файлов.

---

## Полезные ссылки

### Документация проекта
- [README.md](README.md) - Общее описание
- [ARCHITECTURE.md](ARCHITECTURE.md) - Архитектура
- [API_DOCUMENTATION.md](API_DOCUMENTATION.md) - API документация
- [DEPLOYMENT_GUIDE.md](DEPLOYMENT_GUIDE.md) - Развёртывание
- [SECURITY_GUIDE.md](SECURITY_GUIDE.md) - Безопасность

### Внешние ресурсы
- [T-Bank VoiceKit](https://www.tbank.ru/business/api/) - Документация API транскрипции
- [DeepSeek AI](https://www.deepseek.com/) - Документация AI модели
- [Telegram Bot API](https://core.telegram.org/bots/api) - Документация Telegram
- [Flask](https://flask.palletsprojects.com/) - Документация Flask
- [SQLAlchemy](https://www.sqlalchemy.org/) - Документация ORM

---

## Контакты и поддержка

Для получения помощи или сообщения об ошибках:
1. Проверьте логи системы
2. Изучите раздел Troubleshooting
3. Обратитесь к администратору системы

---

**Версия документа**: 1.3  
**Дата создания**: 2025-01-15  
**Последнее обновление**: 2025-01-20

## История изменений

### Версия 1.3 (2025-01-20)
**Исправления кроссплатформенности и обработки путей**:

1. **Исправлена обработка путей на Ubuntu/Linux**:
   - Добавлена нормализация путей через `Path.resolve()` для получения абсолютных путей
   - Исправлена проблема, когда файлы из FTP не обрабатывались на Ubuntu
   - Пути теперь корректно обрабатываются на обеих ОС (Windows и Linux)

2. **Улучшена обработка путей в FTP синхронизации**:
   - Нормализация базового пути перед созданием структуры папок
   - Нормализация путей скачанных файлов перед передачей в обработчик
   - Проверка существования файлов перед обработкой
   - Добавлено логирование ОС для отладки

3. **Исправлена обработка путей в CallHandler**:
   - Нормализация пути файла из события watchdog
   - Нормализация путей для lock-файлов
   - Обработка ошибок при разрешении путей с fallback на исходный путь

4. **Исправлена функция `_release_lock()`**:
   - Исправлена проверка существования `lock_path` через `nonlocal`
   - Инициализация `lock_path = None` для предотвращения `NameError`
   - Корректная проверка через `lock_path is not None` вместо `locals()`

5. **Обновлена документация**:
   - Добавлен раздел в Troubleshooting FTP о проблемах с путями на Ubuntu
   - Добавлены рекомендации по настройке путей для Linux

**Результат**: Система теперь корректно обрабатывает файлы из FTP на Ubuntu/Linux, пути нормализуются автоматически для обеих платформ.

### Версия 1.2 (2025-11-14)
**Добавлена поддержка FTP/SFTP синхронизации**:

1. **Новый функционал**:
   - Добавлен модуль `call_analyzer/ftp_sync.py` - клиент FTP/SFTP
   - Добавлен модуль `call_analyzer/ftp_sync_manager.py` - менеджер фоновых синхронизаций
   - Добавлена модель `FtpConnection` в базу данных
   - Добавлена страница `/ftp` для управления FTP подключениями
   - Добавлена зависимость `paramiko>=4.0.0` для SFTP

2. **Функции FTP синхронизации**:
   - Поддержка протоколов FTP и SFTP
   - Автоматическая загрузка файлов с удалённых серверов
   - Множественные подключения (разные серверы для разных пользователей)
   - Настраиваемый интервал синхронизации (по умолчанию 60 секунд)
   - Фильтрация файлов по именам (`fs_`, `external-`, `in-`, `вход_`) и расширениям (`.mp3`, `.wav`)
   - Автоматическое размещение в структуру `YYYY/MM/DD`
   - Мониторинг статуса (последняя синхронизация, счётчик файлов, ошибки)

3. **Интеграция с пользовательской конфигурацией**:
   - Выбор источника звонков: "Локальная папка" или "FTP подключение"
   - При выборе FTP: автоматическое скачивание в указанный путь
   - Файлы обрабатываются идентично локальным через watchdog конвейер

4. **Веб-интерфейс**:
   - Добавление/редактирование/удаление FTP подключений
   - Тестирование подключения перед сохранением
   - Ручной запуск синхронизации
   - Активация/деактивация подключений
   - Отображение статуса и статистики

5. **Безопасность**:
   - Пароли при редактировании можно оставлять пустыми (сохраняется существующий)
   - Изоляция подключений между пользователями
   - Логирование всех операций

6. **Обновлена документация**:
   - Добавлен раздел "Модуль синхронизации FTP" в "Основные компоненты"
   - Добавлен раздел "Синхронизация с FTP/SFTP серверами" в "Функциональные возможности"
   - Добавлен полный раздел "Инструкция по работе с FTP" с детальными инструкциями
   - Добавлены FAQ по FTP
   - Добавлен раздел "Troubleshooting FTP"
   - Обновлена структура файлов и папок проекта

**Результат**: Система теперь поддерживает автоматическую синхронизацию звонков с удалённых FTP/SFTP серверов с полной интеграцией в существующий конвейер обработки.

### Версия 1.1 (2025-11-13)
**Исправления в модуле генерации отчетов (`week_full.py`)**:

1. **Исправлена проблема с периодом дат**:
   - Добавлен автоматический сброс времени на начало дня (00:00:00) для `start_date`
   - Добавлен автоматический сброс времени на конец дня (23:59:59) для `end_date`
   - Теперь звонки корректно попадают в указанный период

2. **Исправлена логика поиска папки script_8**:
   - Изменен приоритет поиска: сначала ищется `script_8/`, затем другие папки
   - Исправлена проблема когда система находила `13-13_script/` вместо `script_8/`
   - Файлы анализов теперь корректно копируются из правильной папки

3. **Исправлена функция `get_station_groups()`**:
   - Добавлен `return station_groups` в конце функции
   - Исправлена ошибка "NoneType object has no attribute 'get'"

4. **Добавлена инициализация конфигурации**:
   - В `create_excel_report()` добавлено получение `station_names`, `station_mapping`, `employee_by_extension`
   - В `create_summary_report()` добавлено получение тех же переменных
   - Исправлена ошибка "station_names is not defined"

5. **Улучшена отладка**:
   - Добавлены DEBUG логи для отслеживания процесса копирования файлов
   - Добавлены логи проверки соответствия файлов периоду

**Результат**: Отчеты теперь генерируются корректно, файлы анализов находятся и обрабатываются правильно.

### Версия 1.0 (2025-01-15)
- Первая версия документации
