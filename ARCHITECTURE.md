# Архитектура Call Analyzer

## Обзор архитектуры

Call Analyzer построен по модульной архитектуре с четким разделением ответственности между компонентами. Система состоит из нескольких основных модулей, взаимодействующих через четко определенные интерфейсы.

## Диаграмма архитектуры

```
┌─────────────────────────────────────────────────────────────────┐
│                        Call Analyzer System                     │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│  │   Web UI    │    │  Main App   │    │  Watchdog   │        │
│  │  (Flask)    │    │  (main.py)  │    │  Monitor    │        │
│  └─────────────┘    └─────────────┘    └─────────────┘        │
│         │                   │                   │             │
│         │                   │                   │             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│  │   Config    │    │ Call Handler│    │   Utils     │        │
│  │ Management  │    │  (Core)     │    │ (Helpers)   │        │
│  └─────────────┘    └─────────────┘    └─────────────┘        │
│         │                   │                   │             │
│         │                   │                   │             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐        │
│  │   Reports   │    │ Transfer/   │    │  External   │        │
│  │ Generation  │    │ Recall      │    │   APIs      │        │
│  └─────────────┘    └─────────────┘    └─────────────┘        │
└─────────────────────────────────────────────────────────────────┘
```

## Основные компоненты

### 1. Главное приложение (main.py)

**Ответственность:**
- Инициализация системы
- Управление жизненным циклом приложения
- Планирование задач
- Мониторинг системы

**Ключевые функции:**
```python
def main():
    """Главная функция приложения"""
    setup_logging()
    initialize_watchdog()
    start_scheduler()
    run_main_loop()

def setup_logging():
    """Настройка системы логирования"""

def initialize_watchdog():
    """Инициализация мониторинга файлов"""

def start_scheduler():
    """Запуск планировщика задач"""
```

**Зависимости:**
- Watchdog для мониторинга файлов
- APScheduler для планирования задач
- Call Handler для обработки звонков

### 2. Обработчик звонков (call_handler.py)

**Ответственность:**
- Обработка новых аудиофайлов
- Координация транскрипции и анализа
- Управление жизненным циклом обработки звонка

**Ключевые классы:**
```python
class CallHandler(FileSystemEventHandler):
    """Обработчик событий файловой системы"""
    
    def on_created(self, event):
        """Обработка создания нового файла"""
    
    def transcribe_and_analyze(self, file_path):
        """Основная функция обработки звонка"""

def speechmatics_send_file(file_path):
    """Отправка файла на транскрипцию"""

def thebai_analyze(transcript, prompt):
    """Анализ транскрипта через AI"""
```

**Архитектурные паттерны:**
- Observer Pattern для обработки событий файловой системы
- Chain of Responsibility для обработки звонков
- Strategy Pattern для разных типов анализа

### 3. Веб-интерфейс (web_interface/)

**Ответственность:**
- Предоставление пользовательского интерфейса
- Управление конфигурацией
- Мониторинг системы
- Генерация отчетов

**Структура:**
```
web_interface/
├── app.py              # Flask приложение
├── templates/          # HTML шаблоны
│   ├── index.html      # Главная страница
│   ├── config.html     # Конфигурация
│   ├── stations.html   # Управление станциями
│   └── ...
├── static/            # Статические файлы
│   ├── css/           # Стили
│   ├── js/            # JavaScript
│   └── images/        # Изображения
└── requirements.txt   # Зависимости
```

**Архитектурные паттерны:**
- MVC Pattern для разделения логики и представления
- REST API для взаимодействия с фронтендом
- Template Pattern для генерации HTML

### 4. Модуль утилит (utils.py)

**Ответственность:**
- Общие вспомогательные функции
- Работа с внешними API
- Обработка ошибок и уведомлений

**Ключевые функции:**
```python
def wait_for_file(file_path, timeout=30):
    """Ожидание готовности файла"""

def make_request_with_retries(method, url, data=None, max_retries=3):
    """HTTP запросы с повторными попытками"""

def send_alert(message, chat_id=None):
    """Отправка уведомлений в Telegram"""

def normalize_phone_number(phone):
    """Нормализация номеров телефонов"""
```

**Архитектурные паттерны:**
- Utility Pattern для общих функций
- Retry Pattern для надежности
- Adapter Pattern для внешних API

### 5. Модуль отчетов (reports/)

**Ответственность:**
- Генерация различных типов отчетов
- Анализ данных звонков
- Экспорт в Excel

**Структура:**
```
reports/
├── __init__.py
├── week_full.py        # Еженедельные отчеты
├── rr_3.py            # Отчеты по станциям Retrack
├── rr_bad.py          # Отчеты по проблемным звонкам
└── skolko_52.py       # Специальные отчеты
```

**Архитектурные паттерны:**
- Factory Pattern для создания разных типов отчетов
- Template Method Pattern для генерации отчетов
- Strategy Pattern для разных форматов экспорта

### 6. Модуль переводов и отзывов (transfer_recall/)

**Ответственность:**
- Управление переводами клиентов между станциями
- Управление отзывами клиентов
- Отслеживание сроков и уведомлений

**Структура:**
```
transfer_recall/
├── __init__.py
├── transfer.py        # Управление переводами
├── recall.py          # Управление отзывами
├── transfer_prompt.yaml
└── recall_prompt.yaml
```

**Архитектурные паттерны:**
- State Pattern для управления состояниями переводов/отзывов
- Observer Pattern для уведомлений
- Command Pattern для операций с переводами

## Потоки данных

### 1. Обработка нового звонка

```
Новый MP3 файл → Watchdog → CallHandler → Транскрипция → AI Анализ → Сохранение → Уведомления
```

**Детальный поток:**
1. **Обнаружение файла:** Watchdog обнаруживает новый MP3 файл
2. **Валидация:** Проверка формата и размера файла
3. **Транскрипция:** Отправка в Speechmatics API
4. **Ожидание результата:** Polling статуса транскрипции
5. **AI Анализ:** Анализ через DeepSeek API
6. **Сохранение:** Сохранение результатов в файлы
7. **Уведомления:** Отправка уведомлений в Telegram
8. **Дополнительная обработка:** Проверка на переводы/отзывы

### 2. Генерация отчета

```
Запрос отчета → Сбор данных → AI Анализ → Генерация Excel → Отправка в Telegram
```

**Детальный поток:**
1. **Планирование:** Scheduler запускает генерацию отчета
2. **Сбор данных:** Сбор транскриптов за период
3. **Анализ:** AI анализ каждого звонка
4. **Агрегация:** Суммирование результатов по станциям
5. **Генерация Excel:** Создание отчета с графиками
6. **Отправка:** Отправка в соответствующие чаты

### 3. Управление конфигурацией

```
Веб-интерфейс → Валидация → Сохранение → Перезагрузка конфигурации → Применение изменений
```

## Внешние зависимости

### 1. Speechmatics API
- **Назначение:** Транскрипция аудиофайлов
- **Интеграция:** HTTP REST API
- **Обработка ошибок:** Retry механизм, fallback стратегии

### 2. DeepSeek API (TheB.ai)
- **Назначение:** AI анализ транскриптов
- **Интеграция:** HTTP REST API
- **Обработка ошибок:** Retry механизм, кэширование

### 3. Telegram API
- **Назначение:** Уведомления и отчеты
- **Интеграция:** HTTP REST API
- **Обработка ошибок:** Retry механизм, логирование

## Конфигурация

### Иерархия конфигурации

1. **config.txt** - Основные параметры системы
2. **prompts.yaml** - Промпты для AI анализа
3. **additional_vocab.yaml** - Дополнительная лексика
4. **transfer_cases.json** - Данные переводов
5. **recall_cases.json** - Данные отзывов

### Управление конфигурацией

```python
class ConfigManager:
    """Менеджер конфигурации"""
    
    def load_config(self):
        """Загрузка конфигурации из файлов"""
    
    def save_config(self, config):
        """Сохранение конфигурации"""
    
    def validate_config(self, config):
        """Валидация конфигурации"""
    
    def reload_config(self):
        """Перезагрузка конфигурации без перезапуска"""
```

## Обработка ошибок

### Стратегии обработки ошибок

1. **Retry Pattern:** Повторные попытки для временных ошибок
2. **Circuit Breaker:** Отключение проблемных сервисов
3. **Fallback:** Резервные стратегии при недоступности сервисов
4. **Graceful Degradation:** Продолжение работы с ограниченным функционалом

### Логирование

```python
import logging

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    handlers=[
        logging.FileHandler('logs/call_analyzer.log'),
        logging.StreamHandler()
    ]
)
```

## Масштабируемость

### Горизонтальное масштабирование

1. **Разделение по станциям:** Каждая станция может работать на отдельном сервере
2. **Микросервисная архитектура:** Разделение на независимые сервисы
3. **Балансировка нагрузки:** Распределение нагрузки между серверами

### Вертикальное масштабирование

1. **Оптимизация Python:** Профилирование и оптимизация кода
2. **Кэширование:** Redis для кэширования результатов
3. **Асинхронная обработка:** Использование asyncio для параллельной обработки

## Безопасность

### Принципы безопасности

1. **Принцип наименьших привилегий:** Минимальные права доступа
2. **Шифрование:** Шифрование чувствительных данных
3. **Валидация:** Строгая валидация всех входных данных
4. **Аудит:** Логирование всех операций

### Защита API ключей

```python
import os
from cryptography.fernet import Fernet

class SecureConfig:
    """Безопасное хранение конфигурации"""
    
    def __init__(self):
        self.cipher = Fernet(os.environ['ENCRYPTION_KEY'])
    
    def encrypt_value(self, value):
        """Шифрование значения"""
        return self.cipher.encrypt(value.encode())
    
    def decrypt_value(self, encrypted_value):
        """Расшифровка значения"""
        return self.cipher.decrypt(encrypted_value).decode()
```

## Мониторинг и наблюдаемость

### Метрики

1. **Производительность:** Время обработки звонков, использование ресурсов
2. **Надежность:** Количество ошибок, доступность сервисов
3. **Бизнес-метрики:** Количество обработанных звонков, качество анализа

### Логирование

1. **Структурированные логи:** JSON формат для машинной обработки
2. **Корреляция:** Уникальные ID для отслеживания запросов
3. **Ротация логов:** Автоматическая ротация и архивация

### Алерты

1. **Критические ошибки:** Немедленные уведомления
2. **Производительность:** Предупреждения о замедлении
3. **Бизнес-логика:** Уведомления о важных событиях

## Развертывание

### Контейнеризация

```dockerfile
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["python", "web_interface/app.py"]
```

### Оркестрация

```yaml
# docker-compose.yml
version: '3.8'

services:
  call-analyzer:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    environment:
      - SPEECHMATICS_API_KEY=${SPEECHMATICS_API_KEY}
      - THEBAI_API_KEY=${THEBAI_API_KEY}
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
```

## Будущие улучшения

### Планируемые изменения

1. **Микросервисная архитектура:** Разделение на независимые сервисы
2. **Event-driven архитектура:** Использование message queues
3. **Machine Learning:** Интеграция ML моделей для улучшения анализа
4. **Real-time аналитика:** Потоковая обработка данных
5. **Multi-tenant:** Поддержка нескольких клиентов

### Технический долг

1. **Рефакторинг:** Улучшение структуры кода
2. **Тестирование:** Увеличение покрытия тестами
3. **Документация:** Улучшение документации API
4. **Производительность:** Оптимизация медленных операций


